"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.optionHelp = exports.toolName = void 0;
const server_1 = require("./repl/server/server");
const net_1 = require("./repl/server/net");
const version_1 = require("../util/version");
const command_line_usage_1 = __importDefault(require("command-line-usage"));
const log_1 = require("../util/log");
const ansi_1 = require("../util/ansi");
const command_line_args_1 = __importDefault(require("command-line-args"));
const config_1 = require("../config");
const assert_1 = require("../util/assert");
const scripts_info_1 = require("./common/scripts-info");
const shell_1 = require("../r-bridge/shell");
const execute_1 = require("./repl/execute");
const repl_main_1 = require("./repl/commands/repl-main");
const core_1 = require("./repl/core");
const repl_version_1 = require("./repl/commands/repl-version");
const print_version_1 = require("./repl/print-version");
const flowr_main_options_1 = require("./flowr-main-options");
const tree_sitter_executor_1 = require("../r-bridge/lang-4.x/tree-sitter/tree-sitter-executor");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
exports.toolName = 'flowr';
exports.optionHelp = [
    {
        header: `flowR (version ${(0, version_1.flowrVersion)().toString()})`,
        content: 'A static dataflow analyzer and program slicer for R programs'
    },
    {
        header: 'Synopsis',
        content: [
            `$ ${exports.toolName} {bold --help}`,
            `$ ${exports.toolName} {bold --version}`,
            `$ ${exports.toolName} {bold --server}`,
            `$ ${exports.toolName} {bold --execute} {italic ":parse 2 - 4"}`,
            `$ ${exports.toolName} {bold slicer} {bold --help}`,
        ]
    },
    {
        header: 'Options',
        optionList: flowr_main_options_1.flowrMainOptionDefinitions
    }
];
const options = (0, command_line_args_1.default)(flowr_main_options_1.flowrMainOptionDefinitions);
log_1.log.updateSettings(l => l.settings.minLevel = options.verbose ? 1 /* LogLevel.Trace */ : 5 /* LogLevel.Error */);
log_1.log.info('running with options', options);
if (options['no-ansi']) {
    log_1.log.info('disabling ansi colors');
    (0, ansi_1.setFormatter)(ansi_1.voidFormatter);
}
let usedConfig = false;
if (options['config-json']) {
    const config = (0, config_1.parseConfig)(options['config-json']);
    if (config) {
        log_1.log.info(`Using passed config ${JSON.stringify(config)}`);
        (0, config_1.setConfig)(config);
        usedConfig = true;
    }
}
if (!usedConfig) {
    if (options['config-file']) {
        // validate it exists
        if (!fs_1.default.existsSync(path_1.default.resolve(options['config-file']))) {
            log_1.log.error(`Config file '${options['config-file']}' does not exist`);
            process.exit(1);
        }
    }
    (0, config_1.setConfigFile)(options['config-file'] ?? flowr_main_options_1.defaultConfigFile, undefined, true);
}
// for all options that we manually supply that have a config equivalent, set them in the config
if (!options['engine.r-shell.disabled']) {
    (0, config_1.amendConfig)({ engines: [{ type: 'r-shell', rPath: options['r-path'] || options['engine.r-shell.r-path'] }] });
}
if (!options['engine.tree-sitter.disabled']) {
    (0, config_1.amendConfig)({ engines: [{
                type: 'tree-sitter',
                wasmPath: options['engine.tree-sitter.wasm-path'],
                treeSitterWasmPath: options['engine.tree-sitter.tree-sitter-wasm-path']
            }] });
}
if (options['default-engine']) {
    (0, config_1.amendConfig)({ defaultEngine: options['default-engine'] });
}
async function retrieveEngineInstances() {
    const engines = {};
    if ((0, config_1.getEngineConfig)('r-shell')) {
        // we keep an active shell session to allow other parse investigations :)
        engines['r-shell'] = new shell_1.RShell({
            revive: 2 /* RShellReviveOptions.Always */,
            onRevive: (code, signal) => {
                const signalText = signal == null ? '' : ` and signal ${signal}`;
                console.log(ansi_1.formatter.format(`R process exited with code ${code}${signalText}. Restarting...`, { color: 5 /* Colors.Magenta */, effect: ansi_1.ColorEffect.Foreground }));
                console.log((0, ansi_1.italic)(`If you want to exit, press either Ctrl+C twice, or enter ${(0, ansi_1.bold)(':quit')}`));
            }
        });
    }
    if ((0, config_1.getEngineConfig)('tree-sitter')) {
        await tree_sitter_executor_1.TreeSitterExecutor.initTreeSitter();
        engines['tree-sitter'] = new tree_sitter_executor_1.TreeSitterExecutor();
    }
    let defaultEngine = (0, config_1.getConfig)().defaultEngine;
    if (!defaultEngine || !engines[defaultEngine]) {
        // if a default engine isn't specified, we just take the first one we have
        defaultEngine = Object.keys(engines)[0];
    }
    log_1.log.info(`Using engines ${Object.keys(engines).join(', ')} with default ${defaultEngine}`);
    return { engines, default: defaultEngine };
}
async function mainRepl() {
    if (options.script) {
        const target = scripts_info_1.scripts[options.script].target;
        (0, assert_1.guard)(target !== undefined, `Unknown script ${options.script}, pick one of ${(0, flowr_main_options_1.getScriptsText)()}.`);
        console.log(`Running script '${ansi_1.formatter.format(options.script, { style: 1 /* FontStyles.Bold */ })}'`);
        log_1.log.debug(`Script maps to "${target}"`);
        await (0, execute_1.waitOnScript)(`${__dirname}/${target}`, process.argv.slice(3), undefined, true);
        process.exit(0);
    }
    if (options.help) {
        console.log((0, command_line_usage_1.default)(exports.optionHelp));
        process.exit(0);
    }
    const engines = await retrieveEngineInstances();
    const defaultEngine = engines.engines[engines.default];
    if (options.version) {
        for (const engine of Object.values(engines.engines)) {
            await (0, repl_version_1.printVersionInformation)(repl_main_1.standardReplOutput, engine);
            engine?.close();
        }
        process.exit(0);
    }
    const end = () => {
        if (options.execute === undefined) {
            console.log(`\n${(0, ansi_1.italic)('Exiting...')}`);
        }
        Object.values(engines.engines).forEach(e => e?.close());
        process.exit(0);
    };
    // hook some handlers
    process.on('SIGINT', end);
    process.on('SIGTERM', end);
    const allowRSessionAccess = options['r-session-access'] ?? false;
    if (options.execute) {
        await (0, core_1.replProcessAnswer)(repl_main_1.standardReplOutput, options.execute, defaultEngine, allowRSessionAccess);
    }
    else {
        await (0, print_version_1.printVersionRepl)(defaultEngine);
        await (0, core_1.repl)({ parser: defaultEngine, allowRSessionAccess });
    }
    process.exit(0);
}
async function mainServer(backend = new net_1.NetServer()) {
    const engines = await retrieveEngineInstances();
    const end = () => {
        if (options.execute === undefined) {
            console.log(`\n${(0, ansi_1.italic)('Exiting...')}`);
        }
        Object.values(engines.engines).forEach(e => e?.close());
        process.exit(0);
    };
    // hook some handlers
    process.on('SIGINT', end);
    process.on('SIGTERM', end);
    await new server_1.FlowRServer(engines.engines, engines.default, options['r-session-access'], backend).start(options.port);
}
if (options.server) {
    void mainServer(options.ws ? new net_1.WebSocketServerWrapper() : new net_1.NetServer());
}
else {
    void mainRepl();
}
//# sourceMappingURL=flowr.js.map