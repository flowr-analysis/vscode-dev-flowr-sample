"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryStarCommand = exports.queryCommand = void 0;
const default_pipelines_1 = require("../../../core/steps/pipeline/default-pipelines");
const retriever_1 = require("../../../r-bridge/retriever");
const args_1 = require("../../../util/args");
const ansi_1 = require("../../../util/ansi");
const schema_1 = require("../../../util/schema");
const query_1 = require("../../../queries/query");
const json_1 = require("../../../util/json");
const query_print_1 = require("../../../queries/query-print");
async function getDataflow(parser, remainingLine) {
    return await (0, default_pipelines_1.createDataflowPipeline)(parser, {
        request: (0, retriever_1.requestFromInput)(remainingLine.trim())
    }).allRemainingSteps();
}
function printHelp(output) {
    output.stderr(`Format: ${(0, ansi_1.italic)(':query "<query>" <code>', output.formatter)}`);
    output.stdout('The query is an array of query objects to represent multiple queries. Each query object may have the following properties:');
    output.stdout((0, schema_1.describeSchema)((0, query_1.AnyQuerySchema)(), output.formatter));
    output.stdout(`\n\nThe example ${(0, ansi_1.italic)(':query "[{\\"type\\": \\"call-context\\", \\"callName\\": \\"mean\\" }]" mean(1:10)', output.formatter)} would return the call context of the mean function.`);
    output.stdout('As a convenience, we interpret any (non-help, non-@) string not starting with \'[\' as a regex for the simple call-context query.');
    output.stdout(`Hence, ${(0, ansi_1.italic)(':query "mean" mean(1:10)', output.formatter)} is equivalent to the above example.`);
    output.stdout('Similarly, \'@<type>\' is interpreted as a query of the given type.');
    output.stdout(`With this, ${(0, ansi_1.italic)(':query @config', output.formatter)} prints the result of the config query.`);
}
async function processQueryArgs(line, parser, output) {
    const args = (0, args_1.splitAtEscapeSensitive)(line);
    const query = args.shift();
    if (!query) {
        output.stderr('No query provided, use \':query help\' to get more information.');
        return;
    }
    if (query === 'help') {
        printHelp(output);
        return;
    }
    let parsedQuery = [];
    if (query.startsWith('@')) {
        parsedQuery = [{ type: query.slice(1) }];
        const validationResult = (0, query_1.QueriesSchema)().validate(parsedQuery);
        if (validationResult.error) {
            output.stderr(`Invalid query: ${validationResult.error.message}`);
            printHelp(output);
            return;
        }
    }
    else if (query.startsWith('[')) {
        parsedQuery = JSON.parse(query);
        const validationResult = (0, query_1.QueriesSchema)().validate(parsedQuery);
        if (validationResult.error) {
            output.stderr(`Invalid query: ${validationResult.error.message}`);
            printHelp(output);
            return;
        }
    }
    else {
        parsedQuery = [{ type: 'call-context', callName: query }];
    }
    const processed = await getDataflow(parser, args.join(' '));
    return {
        query: (0, query_1.executeQueries)({ dataflow: processed.dataflow, ast: processed.normalize }, parsedQuery),
        processed
    };
}
exports.queryCommand = {
    description: `Query the given R code, start with '${retriever_1.fileProtocol}' to indicate a file. The query is to be a valid query in json format (use 'help' to get more information).`,
    usageExample: ':query "<query>" <code>',
    aliases: [],
    script: false,
    fn: async (output, parser, remainingLine) => {
        const totalStart = Date.now();
        const results = await processQueryArgs(remainingLine, parser, output);
        const totalEnd = Date.now();
        if (results) {
            output.stdout((0, query_print_1.asciiSummaryOfQueryResult)(ansi_1.ansiFormatter, totalEnd - totalStart, results.query, results.processed));
        }
    }
};
exports.queryStarCommand = {
    description: 'Similar to query, but returns the output in json format.',
    usageExample: ':query* <query> <code>',
    aliases: [],
    script: false,
    fn: async (output, shell, remainingLine) => {
        const results = await processQueryArgs(remainingLine, shell, output);
        if (results) {
            output.stdout(JSON.stringify(results.query, json_1.jsonReplacer));
        }
    }
};
//# sourceMappingURL=repl-query.js.map