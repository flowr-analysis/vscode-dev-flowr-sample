"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeCommand = void 0;
exports.tryExecuteRShellCommand = tryExecuteRShellCommand;
const ansi_1 = require("../../../util/ansi");
const shell_1 = require("../../../r-bridge/shell");
async function tryExecuteRShellCommand(output, parser, statement, allowRSessionAccess) {
    if (!allowRSessionAccess) {
        output.stderr(`${output.formatter.format('You are not allowed to execute arbitrary R code.', { style: 1 /* FontStyles.Bold */, color: 1 /* Colors.Red */, effect: ansi_1.ColorEffect.Foreground })}\nIf you want to do so, please restart flowR with the ${output.formatter.format('--r-session-access', { style: 1 /* FontStyles.Bold */ })} flag. Please be careful of the security implications of this action.`);
    }
    else if (parser instanceof shell_1.RShell) {
        await executeRShellCommand(output, parser, statement);
    }
    else {
        output.stderr(`Executing arbitrary R code is only possible when using the r-shell engine as the default engine. Enable it using the configuration file or the ${output.formatter.format('--default-engine r-shell', { style: 1 /* FontStyles.Bold */ })} command line option.`);
    }
}
async function executeRShellCommand(output, shell, statement) {
    try {
        const result = await shell.sendCommandWithOutput(statement, {
            from: 'both',
            automaticallyTrimOutput: true
        });
        output.stdout(`${(0, ansi_1.italic)(result.join('\n'), output.formatter)}\n`);
    }
    catch (e) {
        output.stderr(`Error while executing '${statement}': ${e.message}`);
    }
}
exports.executeCommand = {
    description: 'Execute the given code as R code (essentially similar to using now command). This requires the `--r-session-access` flag to be set and requires the r-shell engine.',
    usageExample: ':execute',
    aliases: ['e', 'r'],
    script: false,
    fn: tryExecuteRShellCommand
};
//# sourceMappingURL=repl-execute.js.map