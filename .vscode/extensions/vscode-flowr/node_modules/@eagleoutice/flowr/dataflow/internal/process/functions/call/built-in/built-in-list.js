"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processList = processList;
const r_function_call_1 = require("../../../../../../r-bridge/lang-4.x/ast/model/nodes/r-function-call");
const type_1 = require("../../../../../../r-bridge/lang-4.x/ast/model/type");
const resolve_by_name_1 = require("../../../../../environments/resolve-by-name");
const known_call_handling_1 = require("../known-call-handling");
const config_1 = require("../../../../../../config");
/**
 * Process a list call.
 *
 * Example:
 * ```r
 * list(a = 1, b = 2)
 * ```
 */
function processList(name, args, rootId, data) {
    if (!(0, config_1.getConfig)().solver.pointerTracking) {
        return (0, known_call_handling_1.processKnownFunctionCall)({ name, args, rootId, data }).information;
    }
    const namedArguments = [];
    for (const arg of args) {
        // Skip non named arguments
        if (arg === r_function_call_1.EmptyArgument || arg.type !== type_1.RType.Argument || arg.name === undefined) {
            continue;
        }
        let newIndex = {
            lexeme: arg.name.content,
            nodeId: arg.info.id,
        };
        // Check whether argument value is non-primitive
        if (arg.value?.type === type_1.RType.Symbol) {
            const defs = (0, resolve_by_name_1.resolveByName)(arg.value.lexeme, data.environment);
            const indices = defs?.flatMap(index => index.indicesCollection ?? []);
            if (indices) {
                newIndex = {
                    ...newIndex,
                    subIndices: indices,
                };
            }
        }
        namedArguments.push(newIndex);
    }
    const indices = {
        indices: namedArguments,
        isContainer: true,
    };
    return (0, known_call_handling_1.processKnownFunctionCall)({ name, args, rootId, data }, [indices]).information;
}
//# sourceMappingURL=built-in-list.js.map