"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReferenceTypeReverseMapping = exports.ReferenceType = void 0;
exports.isReferenceType = isReferenceType;
/**
 * Each reference has exactly one reference type, stored as the respective number.
 * However, when checking, we may want to allow for one of several types,
 * allowing the combination of the respective bitmasks.
 *
 * Having reference types is important as R separates a variable definition from
 * a function when resolving an {@link Identifier|identifier}.
 * In `c <- 3; print(c(1, 2))` the call to `c` works normally (as the vector constructor),
 * while writing `c <- function(...) ..1` overshadows the built-in and causes `print` to only output the first element.
 *
 * @see {@link isReferenceType} - for checking if a (potentially joint) reference type contains a certain type
 * @see {@link ReferenceTypeReverseMapping} - for debugging
 */
var ReferenceType;
(function (ReferenceType) {
    /** The identifier type is unknown */
    ReferenceType[ReferenceType["Unknown"] = 1] = "Unknown";
    /** The identifier is defined by a function (includes built-in function) */
    ReferenceType[ReferenceType["Function"] = 2] = "Function";
    /** The identifier is defined by a variable (includes parameter and argument) */
    ReferenceType[ReferenceType["Variable"] = 4] = "Variable";
    /** The identifier is defined by a constant (includes built-in constant) */
    ReferenceType[ReferenceType["Constant"] = 8] = "Constant";
    /** The identifier is defined by a parameter (which we know nothing about at the moment) */
    ReferenceType[ReferenceType["Parameter"] = 16] = "Parameter";
    /** The identifier is defined by an argument (which we know nothing about at the moment) */
    ReferenceType[ReferenceType["Argument"] = 32] = "Argument";
    /** The identifier is defined by a built-in value/constant */
    ReferenceType[ReferenceType["BuiltInConstant"] = 64] = "BuiltInConstant";
    /** The identifier is defined by a built-in function */
    ReferenceType[ReferenceType["BuiltInFunction"] = 128] = "BuiltInFunction";
})(ReferenceType || (exports.ReferenceType = ReferenceType = {}));
/** Reverse mapping of the reference types so you can get the name from the bitmask (useful for debugging) */
exports.ReferenceTypeReverseMapping = new Map(Object.entries(ReferenceType).map(([k, v]) => [v, k]));
/**
 * Check if the reference types have an overlapping type!
 */
function isReferenceType(t, target) {
    return (t & target) !== 0;
}
//# sourceMappingURL=identifier.js.map