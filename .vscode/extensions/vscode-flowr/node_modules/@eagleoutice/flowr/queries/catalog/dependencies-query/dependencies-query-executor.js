"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeDependenciesQuery = executeDependenciesQuery;
const query_1 = require("../../query");
const dependencies_query_format_1 = require("./dependencies-query-format");
const graph_1 = require("../../../dataflow/graph/graph");
const log_1 = require("../../../util/log");
const type_1 = require("../../../r-bridge/lang-4.x/ast/model/type");
const retriever_1 = require("../../../r-bridge/retriever");
const r_function_call_1 = require("../../../r-bridge/lang-4.x/ast/model/nodes/r-function-call");
const visitor_1 = require("../../../r-bridge/lang-4.x/ast/model/processing/visitor");
const assert_1 = require("../../../util/assert");
const objects_1 = require("../../../util/objects");
const SupportedVertexTypes = [type_1.RType.String, type_1.RType.Logical, type_1.RType.Number];
function executeDependenciesQuery(data, queries) {
    if (queries.length !== 1) {
        log_1.log.warn('Dependencies query expects only up to one query, but got ', queries.length, 'only using the first query');
    }
    const now = Date.now();
    const [query] = queries;
    const ignoreDefault = query.ignoreDefaultFunctions ?? false;
    const libraryFunctions = getFunctionsToCheck(query.libraryFunctions, ignoreDefault, dependencies_query_format_1.LibraryFunctions);
    const sourceFunctions = getFunctionsToCheck(query.sourceFunctions, ignoreDefault, dependencies_query_format_1.SourceFunctions);
    const readFunctions = getFunctionsToCheck(query.readFunctions, ignoreDefault, dependencies_query_format_1.ReadFunctions);
    const writeFunctions = getFunctionsToCheck(query.writeFunctions, ignoreDefault, dependencies_query_format_1.WriteFunctions);
    const numberOfFunctions = libraryFunctions.length + sourceFunctions.length + readFunctions.length + writeFunctions.length;
    const results = numberOfFunctions === 0 ? { kinds: {}, '.meta': { timing: 0 } } : (0, query_1.executeQueriesOfSameType)(data, ...makeCallContextQuery(libraryFunctions, 'library'), ...makeCallContextQuery(sourceFunctions, 'source'), ...makeCallContextQuery(readFunctions, 'read'), ...makeCallContextQuery(writeFunctions, 'write'));
    const getLexeme = (argument, id) => {
        if ((argument && argument !== dependencies_query_format_1.Unknown) || !id) {
            return undefined;
        }
        let get = data.ast.idMap.get(id);
        if (!get) {
            return undefined;
        }
        if (get.type === type_1.RType.Argument) {
            get = get.value;
        }
        return get?.info.fullLexeme ?? get?.lexeme;
    };
    const libraries = getResults(data, results, 'library', libraryFunctions, (id, vertex, argId, argument) => ({
        nodeId: id,
        functionName: vertex.name,
        lexemeOfArgument: getLexeme(argument, argId),
        libraryName: argument ?? dependencies_query_format_1.Unknown
    }), [type_1.RType.Symbol]);
    if (!ignoreDefault) {
        /* for libraries, we have to additionally track all uses of `::` and `:::`, for this we currently simply traverse all uses */
        (0, visitor_1.visitAst)(data.ast.ast, n => {
            if (n.type === type_1.RType.Symbol && n.namespace) {
                /* we should improve the identification of ':::' */
                libraries.push({
                    nodeId: n.info.id,
                    functionName: (n.info.fullLexeme ?? n.lexeme).includes(':::') ? ':::' : '::',
                    libraryName: n.namespace
                });
            }
        });
    }
    const sourcedFiles = getResults(data, results, 'source', sourceFunctions, (id, vertex, argId, argument, linkedIds) => ({
        nodeId: id,
        functionName: vertex.name,
        file: argument ?? dependencies_query_format_1.Unknown,
        lexemeOfArgument: getLexeme(argument, argId),
        linkedIds: linkedIds?.length ? linkedIds : undefined
    }));
    const readData = getResults(data, results, 'read', readFunctions, (id, vertex, argId, argument, linkedIds) => ({
        nodeId: id,
        functionName: vertex.name,
        source: argument ?? dependencies_query_format_1.Unknown,
        lexemeOfArgument: getLexeme(argument, argId),
        linkedIds: linkedIds?.length ? linkedIds : undefined
    }));
    const writtenData = getResults(data, results, 'write', writeFunctions, (id, vertex, argId, argument, linkedIds) => ({
        nodeId: id,
        functionName: vertex.name,
        // write functions that don't have argIndex are assumed to write to stdout
        destination: argument ?? (linkedIds?.length ? dependencies_query_format_1.Unknown : 'stdout'),
        lexemeOfArgument: getLexeme(argument, argId),
        linkedIds: linkedIds?.length ? linkedIds : undefined
    }));
    return {
        '.meta': {
            timing: Date.now() - now
        },
        libraries, sourcedFiles, readData, writtenData
    };
}
function makeCallContextQuery(functions, kind) {
    return functions.map(f => ({
        type: 'call-context',
        callName: f.name,
        includeAliases: false,
        callNameExact: true,
        subkind: f.name,
        linkTo: f.linkTo ? { type: 'link-to-last-call', callName: f.linkTo } : undefined,
        kind
    }));
}
function getResults(data, results, kind, functions, makeInfo, additionalAllowedTypes) {
    const kindEntries = Object.entries(results?.kinds[kind]?.subkinds ?? {});
    return kindEntries.flatMap(([name, results]) => results.flatMap(({ id, linkedIds }) => {
        const vertex = data.dataflow.graph.getVertex(id);
        const info = functions.find(f => f.name === name);
        let index = info.argIdx;
        if (info.argName) {
            const arg = vertex?.args.findIndex(arg => arg !== r_function_call_1.EmptyArgument && arg.name === info.argName);
            if (arg >= 0) {
                index = arg;
            }
        }
        const args = index !== undefined ? getArgumentValue(data, vertex, index, additionalAllowedTypes) : undefined;
        if (!args) {
            const record = (0, objects_1.compactRecord)(makeInfo(id, vertex, undefined, undefined, linkedIds));
            return record ? [record] : [];
        }
        const results = [];
        for (const [arg, values] of args.entries()) {
            for (const value of values) {
                const result = (0, objects_1.compactRecord)(makeInfo(id, vertex, arg, value, linkedIds));
                if (result) {
                    results.push(result);
                }
            }
        }
        return results;
    })) ?? [];
}
/**
 * Get the values of all arguments matching the criteria.
 */
function getArgumentValue({ dataflow: { graph } }, vertex, argumentIndex, additionalAllowedTypes) {
    if (!vertex) {
        return undefined;
    }
    if (argumentIndex === 'unnamed') {
        // return all unnamed arguments
        const references = vertex.args.filter(arg => arg !== r_function_call_1.EmptyArgument && !arg.name).map(graph_1.getReferenceOfArgument).filter(assert_1.isNotUndefined);
        const map = new Map();
        for (const ref of references) {
            let valueNode = graph.idMap?.get(ref);
            if (valueNode?.type === type_1.RType.Argument) {
                valueNode = valueNode.value;
            }
            if (valueNode) {
                const allowedTypes = [...SupportedVertexTypes, ...additionalAllowedTypes ?? []];
                const value = allowedTypes.includes(valueNode.type) ? (0, retriever_1.removeRQuotes)(valueNode.lexeme) : dependencies_query_format_1.Unknown;
                map.set(ref, new Set([value]));
            }
        }
        return map;
    }
    if (vertex.args.length > argumentIndex) {
        const arg = (0, graph_1.getReferenceOfArgument)(vertex.args[argumentIndex]);
        if (!arg) {
            return undefined;
        }
        let valueNode = graph.idMap?.get(arg);
        if (valueNode?.type === type_1.RType.Argument) {
            valueNode = valueNode.value;
        }
        if (valueNode) {
            const allowedTypes = [...SupportedVertexTypes, ...additionalAllowedTypes ?? []];
            return new Map([[arg, new Set([allowedTypes.includes(valueNode.type) ? (0, retriever_1.removeRQuotes)(valueNode.lexeme) : dependencies_query_format_1.Unknown])]]);
        }
    }
    return undefined;
}
function getFunctionsToCheck(customFunctions, ignoreDefaultFunctions, defaultFunctions) {
    const functions = ignoreDefaultFunctions ? [] : [...defaultFunctions];
    if (customFunctions) {
        functions.push(...customFunctions);
    }
    return functions;
}
//# sourceMappingURL=dependencies-query-executor.js.map