"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CallContextQueryDefinition = void 0;
const call_context_query_executor_1 = require("./call-context-query-executor");
const ansi_1 = require("../../../util/ansi");
const time_1 = require("../../../util/time");
const joi_1 = __importDefault(require("joi"));
const query_print_1 = require("../../query-print");
const identify_link_to_last_call_relation_1 = require("./identify-link-to-last-call-relation");
exports.CallContextQueryDefinition = {
    executor: call_context_query_executor_1.executeCallContextQueries,
    asciiSummarizer: (formatter, processed, queryResults, result) => {
        const out = queryResults;
        result.push(`Query: ${(0, ansi_1.bold)('call-context', formatter)} (${(0, time_1.printAsMs)(out['.meta'].timing, 0)})`);
        result.push((0, query_print_1.asciiCallContext)(formatter, out, processed));
        return true;
    },
    schema: joi_1.default.object({
        type: joi_1.default.string().valid('call-context').required().description('The type of the query.'),
        callName: joi_1.default.string().required().description('Regex regarding the function name!'),
        callNameExact: joi_1.default.boolean().optional().description('Should we automatically add the `^` and `$` anchors to the regex to make it an exact match?'),
        kind: joi_1.default.string().optional().description('The kind of the call, this can be used to group calls together (e.g., linking `plot` to `visualize`). Defaults to `.`'),
        subkind: joi_1.default.string().optional().description('The subkind of the call, this can be used to uniquely identify the respective call type when grouping the output (e.g., the normalized name, linking `ggplot` to `plot`). Defaults to `.`'),
        callTargets: joi_1.default.string().valid(...Object.values(identify_link_to_last_call_relation_1.CallTargets)).optional().description('Call targets the function may have. This defaults to `any`. Request this specifically to gain all call targets we can resolve.'),
        includeAliases: joi_1.default.boolean().optional().description('Consider a case like `f <- function_of_interest`, do you want uses of `f` to be included in the results?'),
        fileFilter: joi_1.default.object({
            fileFilter: joi_1.default.string().required().description('Regex that a node\'s file attribute must match to be considered'),
            includeUndefinedFiles: joi_1.default.boolean().optional().description('If `fileFilter` is set, but a nodes `file` attribute is `undefined`, should we include it in the results? Defaults to `true`.')
        }).optional().description('Filter that, when set, a node\'s file attribute must match to be considered'),
        linkTo: joi_1.default.object({
            type: joi_1.default.string().valid('link-to-last-call').required().description('The type of the linkTo sub-query.'),
            callName: joi_1.default.string().required().description('Regex regarding the function name of the last call. Similar to `callName`, strings are interpreted as a regular expression.'),
            ignoreIf: joi_1.default.function().optional().description('Should we ignore this (source) call? Currently, there is no well working serialization for this.'),
            cascadeIf: joi_1.default.function().optional().description('Should we continue searching after the link was created? Currently, there is no well working serialization for this.')
        }).optional().description('Links the current call to the last call of the given kind. This way, you can link a call like `points` to the latest graphics plot etc.')
    }).description('Call context query used to find calls in the dataflow graph')
};
//# sourceMappingURL=call-context-query-format.js.map