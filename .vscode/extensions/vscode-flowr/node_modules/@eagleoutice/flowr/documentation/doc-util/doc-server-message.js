"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.documentServerMessage = documentServerMessage;
exports.printServerMessages = printServerMessages;
exports.inServerContext = inServerContext;
exports.documentServerMessageResponse = documentServerMessageResponse;
const doc_files_1 = require("./doc-files");
const schema_1 = require("../../util/schema");
const ansi_1 = require("../../util/ansi");
const net_1 = require("../../../test/functionality/_helper/net");
const doc_code_1 = require("./doc-code");
const assert_1 = require("../../util/assert");
const time_1 = require("../../util/time");
const messages = [];
function documentServerMessage(description) {
    messages.push(description);
}
async function printServerMessages(shell) {
    let text = '<ul>';
    for (const message of messages) {
        text += '<li>' + await printServerMessage(message, shell) + '</li>\n\n';
    }
    return text + '</ul>';
}
async function inServerContext(shell, fn) {
    return (0, net_1.withSocket)(shell, async (socket, server) => {
        return fn(socket, server);
    })();
}
function explainMsg(msg, type, desc = '', open = false) {
    const bold = open ? s => `<b>${s}</b>` : s => s;
    return `
<li> ${bold('<code>' + msg.type + `</code> (${type})`)}
<details${open ? ' open' : ''}> 

<summary> Show Details </summary>

${desc}

${(0, doc_code_1.jsonWithLimit)(msg)}

</details>
</li>
`;
}
function getDescriptionForMessage(msg, description) {
    if (description === undefined) {
        return '';
    }
    else if (typeof description === 'function') {
        return description(msg);
    }
    else {
        return description ?? '';
    }
}
function explainPingPong(description, received) {
    let result = `<ol>${explainMsg(received[0], 'response', 'The first message is always a hello message.')}`;
    let readReceived = 1;
    /* we received one more than we sent (`hello` :D) */
    for (const msg of description) {
        if (msg.type === 'request') {
            result += explainMsg(msg.message, 'request', getDescriptionForMessage(msg.message, msg.description), msg.mark);
        }
        else {
            const response = received[readReceived++];
            result += explainMsg(response, 'response', getDescriptionForMessage(response, msg.description), msg.mark);
        }
    }
    return result + '</ol>';
}
async function documentServerMessageResponse({ shell, title, messageType, messages }) {
    const start = performance.now();
    const response = await inServerContext(shell, async (socket) => {
        for (const metaMessage of messages) {
            if (metaMessage.type === 'request') {
                socket.send(JSON.stringify(metaMessage.message) + '\n');
            }
            else {
                try {
                    await socket.waitForMessage(metaMessage.expectedType, 20);
                }
                catch {
                    console.error('Failed to receive message', metaMessage.expectedType, 'has', socket.getMessages());
                }
            }
        }
        return socket.getMessages();
    });
    const end = performance.now();
    (0, assert_1.guard)(title !== undefined || messageType !== undefined, 'Either a title or a message type must be given');
    title ??= `Example of the <code>${messageType}</code> Message`;
    return `
<details>
<summary>${title}</summary>

_Note:_ even though we pretty-print these messages, they are sent as a single line, ending with a newline.

The following lists all messages that were sent and received in case you want to reproduce the scenario:

${explainPingPong(messages, response)}

The complete round-trip took ${(0, time_1.printAsMs)(end - start)} (including time required to validate the messages, start, and stop the internal mock server).

</details>
`;
}
function getSchema(definitionPath, def) {
    return def ? `<details>
<summary style="color:gray">Message schema (<code>${def.type}</code>)</summary>

For the definition of the hello message, please see it's implementation at ${(0, doc_files_1.getFilePathMd)(definitionPath)}.

${(0, schema_1.describeSchema)(def.schema, ansi_1.markdownFormatter)}

</details>
` : '';
}
async function printServerMessage({ mermaidSequenceDiagram, text, title, shortDescription, definitionPath, defRequest, defResponse, additionalDefs }, shell) {
    const base = defRequest ?? defResponse;
    (0, assert_1.guard)(base !== undefined, 'At least one of the definitions must be given');
    return `
<a id="message-${base.type}"></a>
<b>${title}</b> Message (<code>${base.type}</code>) 
<details>

<summary style="color:gray"> View Details. <i>${shortDescription}</i> </summary>

\`\`\`mermaid
sequenceDiagram
    autonumber
    participant Client
    participant Server

    ${mermaidSequenceDiagram}
\`\`\`

${await text(shell)}

<hr>

${getSchema(definitionPath, defRequest)}
${getSchema(definitionPath, defResponse)}
${additionalDefs?.map(def => getSchema(definitionPath, def)).join('\n') ?? ''}

<hr>

</details>	
	`;
}
//# sourceMappingURL=doc-server-message.js.map