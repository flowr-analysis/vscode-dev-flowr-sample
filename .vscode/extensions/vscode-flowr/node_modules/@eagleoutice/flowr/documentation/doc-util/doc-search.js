"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegisteredQueries = void 0;
exports.showSearch = showSearch;
exports.registerQueryDocumentation = registerQueryDocumentation;
exports.linkToQueryOfName = linkToQueryOfName;
exports.tocForQueryType = tocForQueryType;
exports.explainQueries = explainQueries;
const pipeline_executor_1 = require("../../core/pipeline-executor");
const default_pipelines_1 = require("../../core/steps/pipeline/default-pipelines");
const retriever_1 = require("../../r-bridge/retriever");
const doc_files_1 = require("./doc-files");
const doc_dfg_1 = require("./doc-dfg");
const doc_code_1 = require("./doc-code");
const time_1 = require("../../util/time");
const flowr_search_executor_1 = require("../../search/flowr-search-executor");
const flowr_search_printer_1 = require("../../search/flowr-search-printer");
const node_id_1 = require("../../r-bridge/lang-4.x/ast/model/processing/node-id");
const dfg_1 = require("../../util/mermaid/dfg");
async function showSearch(shell, code, search, { collapseResult = true } = {}) {
    const now = performance.now();
    const analysis = await new pipeline_executor_1.PipelineExecutor(default_pipelines_1.DEFAULT_DATAFLOW_PIPELINE, {
        parser: shell,
        request: (0, retriever_1.requestFromInput)(code)
    }).allRemainingSteps();
    const result = (0, flowr_search_executor_1.runSearch)(search, analysis);
    const duration = performance.now() - now;
    const metaInfo = `
The search required _${(0, time_1.printAsMs)(duration)}_ (including parsing and normalization and the query) within the generation environment.
	`.trim();
    return `

${(0, doc_code_1.codeBlock)('ts', (0, flowr_search_printer_1.flowrSearchToCode)(search))}

<details style="color:gray"> <summary>Search Visualization</summary>

${(0, doc_code_1.codeBlock)('mermaid', (0, flowr_search_printer_1.flowrSearchToMermaid)(search))}

In the code:

${(0, doc_code_1.codeBlock)('r', code)}

<details style="color:gray"> <summary>JSON Representation</summary>

${(0, doc_code_1.codeBlock)('json', JSON.stringify(search, null, 2))}

</details>

</details>


${collapseResult ? ' <details> <summary style="color:gray">Show Results</summary>' : ''}

The query returns the following vetices (all references to \`x\` in the code):
${result.map(({ node }) => `<b>${node.info.id} ('${(0, node_id_1.recoverContent)(node.info.id, analysis.dataflow.graph)}')</b> at L${(0, dfg_1.formatRange)(node.location)}`).join(', ')}

${metaInfo}	

The returned results are highlighted thick and blue within the dataflow graph:

${await (0, doc_dfg_1.printDfGraphForCode)(shell, code, { showCode: false, switchCodeAndGraph: false, mark: new Set(result.map(({ node }) => node.info.id)) })}


${collapseResult ? '</details>' : ''}

	`;
}
exports.RegisteredQueries = {
    'active': new Map(),
    'virtual': new Map()
};
function registerQueryDocumentation(query, doc) {
    const map = exports.RegisteredQueries[doc.type];
    if (map.has(query)) {
        throw new Error(`Query ${query} already registered`);
    }
    map.set(query, doc);
}
function linkify(name) {
    return name.toLowerCase().replace(/ /g, '-');
}
function linkToQueryOfName(id) {
    const query = exports.RegisteredQueries.active.get(id) ?? exports.RegisteredQueries.virtual.get(id);
    if (!query) {
        throw new Error(`Query ${id} not found`);
    }
    return `[${query.name}](#${linkify(query.name)})`;
}
function tocForQueryType(type) {
    const queries = [...exports.RegisteredQueries[type].entries()].sort(([, { name: a }], [, { name: b }]) => a.localeCompare(b));
    const result = [];
    for (const [id, { name, shortDescription }] of queries) {
        result.push(`1. [${name}](#${linkify(name)}) (\`${id}\`):\\\n    ${shortDescription}`);
    }
    return result.join('\n');
}
async function explainQuery(shell, { name, functionName, functionFile, buildExplanation }) {
    return `
### ${name}

${await buildExplanation(shell)}

<details> 

<summary style="color:gray">Implementation Details</summary>

Responsible for the execution of the ${name} query is \`${functionName}\` in ${(0, doc_files_1.getFilePathMd)(functionFile)}.

</details>	

`;
}
async function explainQueries(shell, type) {
    const queries = [...exports.RegisteredQueries[type].entries()].sort(([, { name: a }], [, { name: b }]) => a.localeCompare(b));
    const result = [];
    for (const [, doc] of queries) {
        result.push(await explainQuery(shell, doc));
    }
    return result.join(`\n${'-'.repeat(5)}\n\n`);
}
//# sourceMappingURL=doc-search.js.map