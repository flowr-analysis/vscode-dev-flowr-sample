"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printNormalizedAst = printNormalizedAst;
exports.printNormalizedAstForCode = printNormalizedAstForCode;
exports.verifyExpectedSubgraph = verifyExpectedSubgraph;
const default_pipelines_1 = require("../../core/steps/pipeline/default-pipelines");
const retriever_1 = require("../../r-bridge/retriever");
const decorate_1 = require("../../r-bridge/lang-4.x/ast/model/processing/decorate");
const resolve_graph_1 = require("../../dataflow/graph/resolve-graph");
const diff_1 = require("../../dataflow/graph/diff");
const assert_1 = require("../../util/assert");
const ast_1 = require("../../util/mermaid/ast");
const time_1 = require("../../util/time");
const doc_files_1 = require("./doc-files");
function printNormalizedAst(ast, prefix = 'flowchart TD\n') {
    return `
\`\`\`mermaid
${(0, ast_1.normalizedAstToMermaid)(ast, prefix)}
\`\`\`
	`;
}
async function printNormalizedAstForCode(parser, code, { showCode = true, prefix = 'flowchart TD\n' } = {}) {
    const now = performance.now();
    const result = await (0, default_pipelines_1.createNormalizePipeline)(parser, {
        request: (0, retriever_1.requestFromInput)(code)
    }).allRemainingSteps();
    const duration = performance.now() - now;
    const metaInfo = `The analysis required _${(0, time_1.printAsMs)(duration)}_ (including parsing with the [${parser.name}](${doc_files_1.FlowrWikiBaseRef}/Engines) engine) within the generation environment.`;
    return '\n\n' + printNormalizedAst(result.normalize.ast, prefix) + (showCode ? `
<details>

<summary style="color:gray">R Code of the Normalized AST</summary>

${metaInfo}

\`\`\`r
${code}
\`\`\`

<details>

<summary style="color:gray">Mermaid Code</summary>

\`\`\`
${(0, ast_1.normalizedAstToMermaid)(result.normalize.ast, prefix)}
\`\`\`

</details>

</details>

` : '\n(' + metaInfo + ')\n\n');
}
/** returns resolved expected df graph */
async function verifyExpectedSubgraph(shell, code, expectedSubgraph) {
    /* we verify that we get what we want first! */
    const info = await (0, default_pipelines_1.createDataflowPipeline)(shell, {
        request: (0, retriever_1.requestFromInput)(code),
        getId: (0, decorate_1.deterministicCountingIdGenerator)(0)
    }).allRemainingSteps();
    expectedSubgraph.setIdMap(info.normalize.idMap);
    expectedSubgraph = (0, resolve_graph_1.resolveDataflowGraph)(expectedSubgraph);
    const report = (0, diff_1.diffOfDataflowGraphs)({ name: 'expected', graph: expectedSubgraph }, { name: 'got', graph: info.dataflow.graph }, {
        leftIsSubgraph: true
    });
    (0, assert_1.guard)(report.isEqual(), () => `report:\n * ${report.comments()?.join('\n * ') ?? ''}`);
    return expectedSubgraph;
}
//# sourceMappingURL=doc-normalized-ast.js.map