"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printDfGraph = printDfGraph;
exports.formatSideEffect = formatSideEffect;
exports.printDfGraphForCode = printDfGraphForCode;
exports.verifyExpectedSubgraph = verifyExpectedSubgraph;
const dfg_1 = require("../../util/mermaid/dfg");
const pipeline_executor_1 = require("../../core/pipeline-executor");
const default_pipelines_1 = require("../../core/steps/pipeline/default-pipelines");
const retriever_1 = require("../../r-bridge/retriever");
const decorate_1 = require("../../r-bridge/lang-4.x/ast/model/processing/decorate");
const resolve_graph_1 = require("../../dataflow/graph/resolve-graph");
const diff_1 = require("../../dataflow/graph/diff");
const assert_1 = require("../../util/assert");
const time_1 = require("../../util/time");
const doc_files_1 = require("./doc-files");
function printDfGraph(graph, mark, simplified = false) {
    return `
\`\`\`mermaid
${(0, dfg_1.graphToMermaid)({
        graph,
        prefix: 'flowchart LR',
        mark,
        simplified
    }).string}
\`\`\`
	`;
}
function formatSideEffect(ef) {
    if (typeof ef === 'object') {
        return `${ef.id} (linked)`;
    }
    else {
        return `${ef}`;
    }
}
async function printDfGraphForCode(parser, code, { simplified = false, mark, showCode = true, codeOpen = false, exposeResult, switchCodeAndGraph = false } = {}) {
    const now = performance.now();
    const result = await (0, default_pipelines_1.createDataflowPipeline)(parser, {
        request: (0, retriever_1.requestFromInput)(code)
    }).allRemainingSteps();
    const duration = performance.now() - now;
    if (switchCodeAndGraph) {
        (0, assert_1.guard)(showCode, 'can not switch code and graph if code is not shown');
    }
    const metaInfo = `The analysis required _${(0, time_1.printAsMs)(duration)}_ (including parse and normalize, using the [${parser.name}](${doc_files_1.FlowrWikiBaseRef}/Engines) engine) within the generation environment.`;
    const dfGraph = printDfGraph(result.dataflow.graph, mark, simplified);
    const simplyText = simplified ? '(simplified) ' : '';
    let resultText = '\n\n';
    if (showCode) {
        const codeText = `\`\`\`r
${code}
\`\`\``;
        resultText += switchCodeAndGraph ? codeText : dfGraph;
        resultText += `
<details${codeOpen ? ' open' : ''}>

<summary style="color:gray">${switchCodeAndGraph ? `${simplyText}Dataflow Graph of the R Code` : `R Code of the ${simplyText}Dataflow Graph`}</summary>

${metaInfo} ${mark ? `The following marks are used in the graph to highlight sub-parts (uses ids): {${[...mark].join(', ')}}.` : ''}
We encountered ${result.dataflow.graph.unknownSideEffects.size > 0 ? 'unknown side effects (with ids: ' + [...result.dataflow.graph.unknownSideEffects].map(formatSideEffect).join(', ') + ')' : 'no unknown side effects'} during the analysis.

${switchCodeAndGraph ? dfGraph : codeText}


</details>

`;
    }
    else {
        resultText += dfGraph + '\n(' + metaInfo + ')\n\n';
    }
    return exposeResult ? [resultText, result] : resultText;
}
/** returns resolved expected df graph */
async function verifyExpectedSubgraph(shell, code, expectedSubgraph) {
    /* we verify that we get what we want first! */
    const info = await new pipeline_executor_1.PipelineExecutor(default_pipelines_1.DEFAULT_DATAFLOW_PIPELINE, {
        parser: shell,
        request: (0, retriever_1.requestFromInput)(code),
        getId: (0, decorate_1.deterministicCountingIdGenerator)(0)
    }).allRemainingSteps();
    expectedSubgraph.setIdMap(info.normalize.idMap);
    expectedSubgraph = (0, resolve_graph_1.resolveDataflowGraph)(expectedSubgraph);
    const report = (0, diff_1.diffOfDataflowGraphs)({ name: 'expected', graph: expectedSubgraph }, { name: 'got', graph: info.dataflow.graph }, {
        leftIsSubgraph: true
    });
    (0, assert_1.guard)(report.isEqual(), () => `report:\n * ${report.comments()?.join('\n * ') ?? ''}`);
    return expectedSubgraph;
}
//# sourceMappingURL=doc-dfg.js.map