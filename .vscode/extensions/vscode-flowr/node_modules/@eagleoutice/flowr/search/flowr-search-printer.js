"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.flowrSearchToMermaid = flowrSearchToMermaid;
exports.flowrSearchToAscii = flowrSearchToAscii;
exports.flowrSearchToCode = flowrSearchToCode;
const flowr_search_traverse_1 = require("./flowr-search-traverse");
const mermaid_1 = require("../util/mermaid/mermaid");
const flowr_search_filters_1 = require("./flowr-search-filters");
const vertex_1 = require("../dataflow/graph/vertex");
const type_1 = require("../r-bridge/lang-4.x/ast/model/type");
/**
 * Converts a {@link FlowrSearchLike} object to a mermaid flowchart.
 */
function flowrSearchToMermaid(search, conf) {
    const out = [conf?.header ?? 'flowchart LR'];
    let count = 0;
    out.push((0, flowr_search_traverse_1.traverseFlowrSearchBuilderType)(search, ({ type, name, args }) => `${count}("<b>${name}</b>(${argsToMermaidString(args)})<br/>_${type}_")`, (acc, { name, args, type }) => `${acc} --> ${++count}["<b>${name}</b>(${argsToMermaidString(args)})<br/>_${type}_"]`));
    return out.join('\n');
}
function argsToMermaidString(args) {
    if (args === undefined) {
        return '';
    }
    return Object.entries(args).map(([key, value]) => `${key}: ${(0, flowr_search_filters_1.isBinaryTree)(value) ? '_' + (0, mermaid_1.escapeMarkdown)((0, flowr_search_filters_1.binaryTreeToString)(value.tree)) + '_'
        : (0, mermaid_1.escapeMarkdown)(JSON.stringify(value))}`)
        .join(', ');
}
function argsToAsciiString(args) {
    if (args === undefined) {
        return '';
    }
    else if (Object.keys(args).length === 1) {
        const key = Object.keys(args)[0];
        const value = args[key];
        return `${key}: ${(0, flowr_search_filters_1.isBinaryTree)(value) ? '_' + (0, flowr_search_filters_1.binaryTreeToString)(value.tree) + '_' : JSON.stringify(value)}`;
    }
    return Object.entries(args).map(([key, value]) => `${key}: ${(0, flowr_search_filters_1.isBinaryTree)(value) ? '_' + (0, flowr_search_filters_1.binaryTreeToString)(value.tree) + '_' : JSON.stringify(value)}`)
        .join(', ');
}
function flowrSearchToAscii(search) {
    return (0, flowr_search_traverse_1.traverseFlowrSearchBuilderType)(search, ({ name, args }) => `${name}(${argsToAsciiString(args)})`, (acc, { name, args }) => `${acc} --> ${name}(${argsToAsciiString(args)})`);
}
function argsToCodeString(args) {
    if (args === undefined) {
        return '';
    }
    return Object.entries(args).map(([, value]) => `${JSON.stringify(value)}`)
        .join(', ');
}
function flowrSearchToCode(search) {
    return (0, flowr_search_traverse_1.traverseFlowrSearchBuilderType)(search, (node) => `Q.${flowrGeneratorToCode(node)}`, (acc, node) => `${acc}.${flowrTransformerToCode(node)}`);
}
function flowrTransformerToCode(node) {
    if (node.name === 'filter') {
        const a = node.args.filter;
        if (vertex_1.ValidVertexTypes.has(String(a))) {
            return `${node.name}(VertexType.${vertex_1.ValidVertexTypeReverse[String(a)]})`;
        }
        else if (type_1.ValidRTypes.has(String(a))) {
            return `${node.name}(RType.${type_1.ValidRTypesReverse[String(a)]})`;
        }
        else if (flowr_search_filters_1.ValidFlowrFilters.has(String(a))) {
            return `${node.name}(FlowrFilter.${flowr_search_filters_1.ValidFlowrFiltersReverse[String(a)]})`;
        }
    }
    return `${node.name}(${argsToCodeString(node.args)})`;
}
function flowrGeneratorToCode(node) {
    if (node.name !== 'get') {
        return `${node.name}(${argsToCodeString(node.args)})`;
    }
    const a = node.args.filter;
    if (Object.keys(a).length === 1) {
        if (a.name) {
            return `var(${JSON.stringify(a.name)})`;
        }
    }
    else if (Object.keys(a).length === 2) {
        if (a.name && a.line) {
            return `varInLine(${JSON.stringify(a.name)}, ${JSON.stringify(a.line)})`;
        }
    }
    return `${node.name}(${argsToCodeString(node.args)})`;
}
//# sourceMappingURL=flowr-search-printer.js.map