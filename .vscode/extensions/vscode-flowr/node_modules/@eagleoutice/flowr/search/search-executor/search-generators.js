"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generators = void 0;
exports.getGenerator = getGenerator;
const flowr_search_1 = require("../flowr-search");
const parse_1 = require("../../slicing/criterion/parse");
const assert_1 = require("../../util/assert");
/**
 * All supported generators!
 */
exports.generators = {
    all: generateAll,
    get: generateGet,
    criterion: generateCriterion,
    from: generateFrom
};
function generateAll(data) {
    return new flowr_search_1.FlowrSearchElements(getAllNodes(data)
        .map(node => ({ node })));
}
function getAllNodes(data) {
    return [...new Map([...data.normalize.idMap.values()].map(n => [n.info.id, n]))
            .values()];
}
function generateGet(data, { filter: { line, column, id, name, nameIsRegex } }) {
    let potentials = (id ?
        [data.normalize.idMap.get(id)].filter(assert_1.isNotUndefined) :
        getAllNodes(data));
    if (line && line < 0) {
        const maxLines = data.normalize.ast.info.fullRange?.[2] ??
            (id ? getAllNodes(data) : potentials).reduce((maxLine, { location }) => location && location[2] > maxLine ? location[2] : maxLine, 0);
        line = maxLines + line + 1;
    }
    if (line && column) {
        potentials = potentials.filter(({ location }) => location?.[0] === line && location?.[1] === column);
    }
    else if (line) {
        potentials = potentials.filter(({ location }) => location?.[0] === line);
    }
    else if (column) {
        potentials = potentials.filter(({ location }) => location?.[1] === column);
    }
    if (nameIsRegex && name) {
        const nameFilter = new RegExp(name);
        potentials = potentials.filter(({ lexeme }) => lexeme && nameFilter.test(lexeme));
    }
    else if (name) {
        potentials = potentials.filter(({ lexeme }) => lexeme === name);
    }
    return new flowr_search_1.FlowrSearchElements(potentials.map(node => ({ node })));
}
function generateFrom(data, args) {
    return new flowr_search_1.FlowrSearchElements(Array.isArray(args.from) ? args.from : [args.from]);
}
function generateCriterion(data, args) {
    return new flowr_search_1.FlowrSearchElements(args.criterion.map(c => ({ node: data.normalize.idMap.get((0, parse_1.slicingCriterionToId)(c, data.normalize.idMap)) })));
}
function getGenerator(name) {
    if (!exports.generators[name]) {
        throw new Error(`Unknown generator: ${name}`);
    }
    return exports.generators[name];
}
//# sourceMappingURL=search-generators.js.map