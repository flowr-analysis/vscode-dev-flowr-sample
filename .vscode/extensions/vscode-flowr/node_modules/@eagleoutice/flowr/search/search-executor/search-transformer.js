"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformers = void 0;
exports.getTransformer = getTransformer;
const flowr_search_filters_1 = require("../flowr-search-filters");
const flowr_search_executor_1 = require("../flowr-search-executor");
const assert_1 = require("../../util/assert");
/**
 * All supported generators!
 */
exports.transformers = {
    first: getFirst,
    last: getLast,
    index: getIndex,
    tail: getTail,
    take: getTake,
    skip: getSkip,
    filter: getFilter,
    merge: getMerge,
    select: getSelect
};
function getTransformer(name) {
    if (!exports.transformers[name]) {
        throw new Error(`Unknown transformer: ${name}`);
    }
    return exports.transformers[name];
}
function compareByLocation({ node: a }, { node: b }) {
    if (a.location && b.location) {
        return a.location[0] - b.location[0] || a.location[1] - b.location[1];
    }
    else if (a.location) {
        return -1;
    }
    return b.location ? 1 : 0;
}
function getFirstByLocation(elements) {
    if (elements.length === 0) {
        return undefined;
    }
    return elements.reduce((acc, cur) => {
        if (acc === undefined) {
            return cur;
        }
        return compareByLocation(acc, cur) < 0 ? acc : cur;
    }, undefined);
}
/* later we can add something like sort partially to get the first k elements */
function sortFully(elements) {
    return elements.sort(compareByLocation);
}
function getLastByLocation(elements) {
    if (elements.length === 0) {
        return undefined;
    }
    return elements.reduce((acc, cur) => {
        if (acc === undefined) {
            return cur;
        }
        return compareByLocation(acc, cur) > 0 ? acc : cur;
    }, undefined);
}
function getFirst(data, elements) {
    return elements.mutate(e => [getFirstByLocation(e)]);
}
function getLast(data, elements) {
    return elements.mutate(e => [getLastByLocation(e)]);
}
function getIndex(data, elements, { index }) {
    return elements.mutate(e => [sortFully(e)[index]]);
}
function getSelect(data, elements, { select }) {
    return elements.mutate(e => {
        sortFully(e);
        return select.map(i => e[i]).filter(assert_1.isNotUndefined);
    });
}
function getTail(data, elements) {
    return elements.mutate(e => {
        const first = getFirstByLocation(e);
        return e.filter(el => el !== first);
    });
}
function getTake(data, elements, { count }) {
    return elements.mutate(e => sortFully(e).slice(0, count));
}
function getSkip(data, elements, { count }) {
    return elements.mutate(e => sortFully(e).slice(count));
}
function getFilter(data, elements, { filter }) {
    return elements.mutate(e => e.filter(({ node }) => (0, flowr_search_filters_1.evalFilter)(filter, { node, normalize: data.normalize, dataflow: data.dataflow })));
}
function getMerge(
/* search has to be unknown because it is a recursive type */
data, elements, other) {
    const resultOther = (0, flowr_search_executor_1.runSearch)(other, data);
    return elements.addAll(resultOther);
}
//# sourceMappingURL=search-transformer.js.map