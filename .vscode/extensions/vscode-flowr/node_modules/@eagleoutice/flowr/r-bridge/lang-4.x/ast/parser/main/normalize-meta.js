"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractLocation = extractLocation;
exports.retrieveMetaStructure = retrieveMetaStructure;
exports.assureTokenType = assureTokenType;
exports.getTokenType = getTokenType;
exports.getWithTokenType = getWithTokenType;
exports.retrieveOpName = retrieveOpName;
exports.ensureChildrenAreLhsAndRhsOrdered = ensureChildrenAreLhsAndRhsOrdered;
exports.ensureExpressionList = ensureExpressionList;
const normalizer_data_1 = require("./normalizer-data");
const range_1 = require("../../../../../util/range");
const type_1 = require("../../model/type");
/**
 * Given a JSON element, extract the source location of the corresponding element in the R-ast
 */
function extractLocation(ast) {
    return (0, range_1.rangeFrom)(ast.line1, ast.col1, ast.line2, ast.col2);
}
/**
 * The JSON object that represents the input contains various meta-information.
 * This function extracts the meta-information and returns it.
 *
 * @param entry - The JSON object to extract the meta-information from
 * @returns An object containing the passed entry, the location of the corresponding R-ast element, and the content of the passed entry
 */
function retrieveMetaStructure(entry) {
    return {
        location: extractLocation(entry),
        content: entry.text
    };
}
function assureTokenType(token, expectedName) {
    if (token !== expectedName) {
        throw new normalizer_data_1.ParseError(`expected name to be ${expectedName}, yet received ${token}`);
    }
}
/**
 * Extract the token-type of the given object. This is based on the knowledge, that all JSON objects created
 * from the R XML have a name attached.
 *
 * @param content  - the JSON object to extract the token-type from
 */
function getTokenType(content) {
    return content.token;
}
function getWithTokenType(obj) {
    return obj.map((content) => ({
        name: getTokenType(content),
        content
    }));
}
function retrieveOpName(operator) {
    /*
   * only real arithmetic ops have their operation as their own name, the others identify via content/text
   */
    return operator.content.text;
}
/**
 * Ensure that the first child is completely before the second child.
 *
 * @param first  - the first child which should be the lhs
 * @param second - the second child which should be the rhs
 */
function ensureChildrenAreLhsAndRhsOrdered(first, second) {
    const firstOtherLoc = extractLocation(first);
    const secondOtherLoc = extractLocation(second);
    if (!(0, range_1.rangeStartsCompletelyBefore)(firstOtherLoc, secondOtherLoc)) {
        throw new normalizer_data_1.ParseError(`expected the first child to be the lhs, yet received ${JSON.stringify(first)} & ${JSON.stringify(second)}`);
    }
}
function ensureExpressionList(node) {
    if (node.type !== type_1.RType.ExpressionList) {
        return {
            type: type_1.RType.ExpressionList,
            grouping: undefined,
            location: node.location,
            info: node.info,
            lexeme: undefined,
            children: [node]
        };
    }
    return node;
}
//# sourceMappingURL=normalize-meta.js.map