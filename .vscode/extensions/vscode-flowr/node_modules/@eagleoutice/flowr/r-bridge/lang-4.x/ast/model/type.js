"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidRTypesReverse = exports.ValidRTypes = exports.RType = exports.RawRType = void 0;
exports.isSymbol = isSymbol;
/**
 * Token types as they are produced by the R parser.
 * Not all of them are directly handled by the normalize step.
 * Some of them are also listed as part of the {@link OperatorDatabase}.
 *
 * @see RType
 */
var RawRType;
(function (RawRType) {
    /** T1 */
    RawRType["NullConst"] = "NULL_CONST";
    /** T2 */
    RawRType["NumericConst"] = "NUM_CONST";
    /** T3 */
    RawRType["StringConst"] = "STR_CONST";
    /** T4 */
    RawRType["EqualAssign"] = "EQ_ASSIGN";
    /** T5 */
    RawRType["EqualFormals"] = "EQ_FORMALS";
    /** T6 */
    RawRType["EqualSub"] = "EQ_SUB";
    /** T7 */
    RawRType["LeftAssign"] = "LEFT_ASSIGN";
    /** T8 */
    RawRType["RightAssign"] = "RIGHT_ASSIGN";
    /** T9 */
    RawRType["And"] = "AND";
    /** T10 */
    RawRType["And2"] = "AND2";
    /** T11 */
    RawRType["Eq"] = "EQ";
    /** T12 */
    RawRType["Ge"] = "GE";
    /** T13 */
    RawRType["Gt"] = "GT";
    /** T14 */
    RawRType["Le"] = "LE";
    /** T15 */
    RawRType["Lt"] = "LT";
    /** T16 */
    RawRType["Ne"] = "NE";
    /** T17 */
    RawRType["Or"] = "OR";
    /** T18 */
    RawRType["Or2"] = "OR2";
    /** T19 */
    RawRType["Pipe"] = "PIPE";
    /** T20 */
    RawRType["Pipebind"] = "PIPEBIND";
    /** T21 */
    RawRType["Special"] = "SPECIAL";
    /** T22 */
    RawRType["Plus"] = "+";
    /** T23 */
    RawRType["Minus"] = "-";
    /** T24 */
    RawRType["Times"] = "*";
    /** T25 */
    RawRType["Div"] = "/";
    /** T26 */
    RawRType["Colon"] = ":";
    /** T27 */
    RawRType["Exclamation"] = "!";
    /** T28 */
    RawRType["Exp"] = "^";
    /** T29 */
    RawRType["Question"] = "?";
    /** T30 */
    RawRType["Tilde"] = "~";
    /** T31 */
    RawRType["Break"] = "BREAK";
    /** T32 */
    RawRType["Else"] = "ELSE";
    /** T33 */
    RawRType["For"] = "FOR";
    /** T34 */
    RawRType["ForCondition"] = "forcond";
    /** T35 */
    RawRType["If"] = "IF";
    /** T36 */
    RawRType["ForIn"] = "IN";
    /** T37 */
    RawRType["Next"] = "NEXT";
    /** T38 */
    RawRType["Repeat"] = "REPEAT";
    /** T39 */
    RawRType["While"] = "WHILE";
    /** T40 */
    RawRType["Function"] = "FUNCTION";
    /** T41 */
    RawRType["Lambda"] = "\\\\";
    /** T42 */
    RawRType["DoubleBracketLeft"] = "LBB";
    /** T43 */
    RawRType["Slot"] = "SLOT";
    /** T44 */
    RawRType["Dollar"] = "$";
    /** T45 */
    RawRType["At"] = "@";
    /** T46 */
    RawRType["BracketLeft"] = "[";
    /** T47 */
    RawRType["BracketRight"] = "]";
    /** T48 */
    RawRType["NsGet"] = "::";
    /** T49 */
    RawRType["NsGetInt"] = ":::";
    /** T50 */
    RawRType["Symbol"] = "SYMBOL";
    /** T51 */
    RawRType["SymbolFunctionCall"] = "SYMBOL_FUNCTION_CALL";
    /** T52 */
    RawRType["SymbolPackage"] = "SYMBOL_PACKAGE";
    /** T53 */
    RawRType["SymbolSub"] = "SYMBOL_SUB";
    /** T54 */
    RawRType["SymbolFormals"] = "SYMBOL_FORMALS";
    /** T55 */
    RawRType["Comment"] = "COMMENT";
    /** T56 */
    RawRType["LineDirective"] = "LINE_DIRECTIVE";
    /** T57 */
    RawRType["ParenLeft"] = "(";
    /** T58 */
    RawRType["ParenRight"] = ")";
    /** T59 */
    RawRType["Comma"] = ",";
    /** T60 */
    RawRType["Semicolon"] = ";";
    /** T61 */
    RawRType["BraceLeft"] = "{";
    /** T62 */
    RawRType["BraceRight"] = "}";
    /** T63 */
    RawRType["Expression"] = "expr";
    /** T64
     *
     * https://github.com/REditorSupport/languageserver/issues/327
     * https://github.com/REditorSupport/languageserver/pull/328
     */
    RawRType["ExprOfAssignOrHelp"] = "expr_or_assign_or_help";
    /**
     * Pre-4.0 version of expr_or_assign_or_help, which was seemingly silently renamed here:
     * https://github.com/wch/r-source/commit/84bbf385f909c0223924c310af6c7c77aa810234
     * (Also see {@link ExprOfAssignOrHelp} documentation for more context.)
     */
    RawRType["LegacyEqualAssign"] = "equal_assign";
    /** T65 */
    RawRType["ExpressionList"] = "exprlist";
})(RawRType || (exports.RawRType = RawRType = {}));
/**
 * Types as we use them for our normalized AST.
 * See {@link RNode} for a union type of all normalized AST nodes in-use.
 * For each enum member, the respective normalized AST node should be referenced
 * in the corresponding comment.
 *
 * @see RawRType
 */
var RType;
(function (RType) {
    /** {@link RAccess} */
    RType["Access"] = "RAccess";
    /** {@link RArgument} */
    RType["Argument"] = "RArgument";
    /** {@link RBinaryOp} */
    RType["BinaryOp"] = "RBinaryOp";
    /** {@link RExpressionList} */
    RType["ExpressionList"] = "RExpressionList";
    /** {@link RForLoop} */
    RType["ForLoop"] = "RForLoop";
    /** {@link RFunctionCall} */
    RType["FunctionCall"] = "RFunctionCall";
    /** {@link RFunctionDefinition} */
    RType["FunctionDefinition"] = "RFunctionDefinition";
    /** {@link RIfThenElse} */
    RType["IfThenElse"] = "RIfThenElse";
    /** {@link RParameter} */
    RType["Parameter"] = "RParameter";
    /** {@link RPipe} */
    RType["Pipe"] = "RPipe";
    /** {@link RRepeatLoop} */
    RType["RepeatLoop"] = "RRepeatLoop";
    /** {@link RUnaryOp} */
    RType["UnaryOp"] = "RUnaryOp";
    /** {@link RWhileLoop} */
    RType["WhileLoop"] = "RWhileLoop";
    /** {@link RBreak} */
    RType["Break"] = "RBreak";
    /** {@link RComment} */
    RType["Comment"] = "RComment";
    /** {@link RLineDirective} */
    RType["LineDirective"] = "RLineDirective";
    /** {@link RLogical} */
    RType["Logical"] = "RLogical";
    /** {@link RNext} */
    RType["Next"] = "RNext";
    /** {@link RNumber} */
    RType["Number"] = "RNumber";
    /** {@link RString} */
    RType["String"] = "RString";
    /** {@link RSymbol} */
    RType["Symbol"] = "RSymbol";
    /* ------ special types ------ */
    /** {@link RDelimiter}.
     * Is not part of the normalized AST but can be found in
     * {@link Source#additionalTokens}.
     */
    RType["Delimiter"] = "RDelimiter";
})(RType || (exports.RType = RType = {}));
exports.ValidRTypes = new Set(Object.values(RType));
exports.ValidRTypesReverse = Object.fromEntries(Object.entries(RType).map(([k, v]) => [v, k]));
const validSymbolTypes = new Set([
    RawRType.Symbol,
    RawRType.SymbolPackage,
    RawRType.SymbolFunctionCall,
    RawRType.NullConst,
    RawRType.StringConst,
    RawRType.ParenLeft,
    RawRType.ParenRight,
    RawRType.BraceLeft,
    RawRType.BraceRight,
    RawRType.Slot,
]);
/**
 * Validates, whether the given type can be used as a symbol in R
 *
 * @see RawRType
 */
function isSymbol(type) {
    return validSymbolTypes.has(type);
}
//# sourceMappingURL=type.js.map