"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeRootObjToAst = normalizeRootObjToAst;
const normalize_meta_1 = require("../../normalize-meta");
const normalize_expressions_1 = require("./normalize-expressions");
const log_1 = require("../../../../../../../util/log");
const arrays_1 = require("../../../../../../../util/arrays");
const type_1 = require("../../../../model/type");
/**
 * Takes the parse dta as object and produces an undecorated, normalized AST.
 */
function normalizeRootObjToAst(data, obj) {
    const exprContent = obj.token;
    (0, normalize_meta_1.assureTokenType)(exprContent, type_1.RawRType.ExpressionList);
    let parsedChildren = [];
    if (obj.children.length > 0) {
        const children = obj.children;
        parsedChildren = (0, normalize_expressions_1.normalizeExpressions)(data, children);
    }
    else {
        log_1.log.debug('no children found, assume empty input');
    }
    const [delimiters, nodes] = (0, arrays_1.partition)(parsedChildren, x => x.type === type_1.RType.Delimiter || x.type === type_1.RType.Comment);
    return {
        type: type_1.RType.ExpressionList,
        children: nodes,
        grouping: undefined,
        lexeme: undefined,
        info: {
            fullRange: data.currentRange,
            additionalTokens: delimiters,
            fullLexeme: data.currentLexeme
        }
    };
}
//# sourceMappingURL=normalize-root.js.map