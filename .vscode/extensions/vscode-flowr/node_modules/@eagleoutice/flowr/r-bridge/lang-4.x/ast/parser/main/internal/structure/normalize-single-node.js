"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeSingleNode = normalizeSingleNode;
const normalize_meta_1 = require("../../normalize-meta");
const normalizer_data_1 = require("../../normalizer-data");
const normalize_line_directive_1 = require("../other/normalize-line-directive");
const assert_1 = require("../../../../../../../util/assert");
const normalize_delimiter_1 = require("./normalize-delimiter");
const type_1 = require("../../../../model/type");
const normalize_comment_1 = require("../other/normalize-comment");
const normalize_expression_1 = require("../expression/normalize-expression");
const normalize_number_1 = require("../values/normalize-number");
const normalize_string_1 = require("../values/normalize-string");
const normalize_break_1 = require("../loops/normalize-break");
const normalize_next_1 = require("../loops/normalize-next");
const normalize_symbol_1 = require("../values/normalize-symbol");
/**
 * Parses a single structure in the ast based on its type (e.g., a string, a number, a symbol, ...)
 *
 * @param data - The data used by the parser (see {@link NormalizerData})
 * @param elem - The element to parse
 *
 * @returns The parsed element as an `RNode` or an `RDelimiter` if it is such.
 */
function normalizeSingleNode(data, elem) {
    switch (elem.name) {
        case type_1.RawRType.ParenLeft:
        case type_1.RawRType.ParenRight:
        case type_1.RawRType.BraceLeft:
        case type_1.RawRType.BraceRight:
            return (0, normalize_delimiter_1.normalizeDelimiter)(elem);
        case type_1.RawRType.Comment:
            return (0, normalize_comment_1.normalizeComment)(data, elem.content);
        case type_1.RawRType.LineDirective:
            return (0, normalize_line_directive_1.normalizeLineDirective)(data, elem.content);
        case type_1.RawRType.ExpressionList:
        case type_1.RawRType.Expression:
        case type_1.RawRType.ExprOfAssignOrHelp:
        case type_1.RawRType.LegacyEqualAssign:
            return (0, normalize_expression_1.normalizeExpression)(data, elem.content);
        case type_1.RawRType.NumericConst:
            return (0, normalize_number_1.normalizeNumber)(data, elem.content);
        case type_1.RawRType.StringConst:
            return (0, normalize_string_1.normalizeString)(data, elem.content);
        case type_1.RawRType.Break:
            return (0, normalize_break_1.normalizeBreak)(data, elem.content);
        case type_1.RawRType.Next:
            return (0, normalize_next_1.normalizeNext)(data, elem.content);
        case type_1.RawRType.Symbol:
        case type_1.RawRType.Slot:
        case type_1.RawRType.NullConst: {
            const symbol = (0, normalize_symbol_1.tryNormalizeSymbol)(data, (0, normalize_meta_1.getWithTokenType)([elem.content]));
            (0, assert_1.guard)(symbol !== undefined, () => `should have been parsed to a symbol but was ${JSON.stringify(symbol)}`);
            return symbol;
        }
        default:
            throw new normalizer_data_1.ParseError(`unknown type ${elem.name} for ${JSON.stringify(elem)} in ${JSON.stringify(data)}`);
    }
}
//# sourceMappingURL=normalize-single-node.js.map