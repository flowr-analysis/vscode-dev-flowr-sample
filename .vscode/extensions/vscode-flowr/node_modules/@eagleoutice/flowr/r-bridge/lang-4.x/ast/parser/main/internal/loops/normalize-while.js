"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryNormalizeWhile = tryNormalizeWhile;
const normalizer_data_1 = require("../../normalizer-data");
const parser_1 = require("../../../json/parser");
const normalize_meta_1 = require("../../normalize-meta");
const type_1 = require("../../../../model/type");
const normalize_single_node_1 = require("../structure/normalize-single-node");
function tryNormalizeWhile(data, [whileToken, leftParen, condition, rightParen, body]) {
    if (whileToken.name !== type_1.RawRType.While) {
        parser_1.parseLog.debug('encountered non-while token for supposed while-loop structure');
        return undefined;
    }
    else if (leftParen.name !== type_1.RawRType.ParenLeft) {
        throw new normalizer_data_1.ParseError(`expected left-parenthesis for while but found ${JSON.stringify(leftParen)}`);
    }
    else if (rightParen.name !== type_1.RawRType.ParenRight) {
        throw new normalizer_data_1.ParseError(`expected right-parenthesis for while but found ${JSON.stringify(rightParen)}`);
    }
    parser_1.parseLog.debug('trying to parse while-loop');
    const parsedCondition = (0, normalize_single_node_1.normalizeSingleNode)(data, condition);
    const parseBody = (0, normalize_single_node_1.normalizeSingleNode)(data, body);
    if (parsedCondition.type === type_1.RType.Delimiter || parseBody.type === type_1.RType.Delimiter) {
        throw new normalizer_data_1.ParseError(`unexpected under-sided while-loop, received ${JSON.stringify([
            parsedCondition,
            parseBody,
        ])} for ${JSON.stringify([whileToken, condition, body])}`);
    }
    const { location, content } = (0, normalize_meta_1.retrieveMetaStructure)(whileToken.content);
    return {
        type: type_1.RType.WhileLoop,
        condition: parsedCondition,
        body: (0, normalize_meta_1.ensureExpressionList)(parseBody),
        lexeme: content,
        location,
        info: {
            fullRange: data.currentRange,
            additionalTokens: [],
            fullLexeme: data.currentLexeme
        }
    };
}
//# sourceMappingURL=normalize-while.js.map