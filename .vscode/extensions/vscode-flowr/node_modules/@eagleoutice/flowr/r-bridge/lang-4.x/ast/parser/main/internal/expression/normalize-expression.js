"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeExpression = normalizeExpression;
const normalize_meta_1 = require("../../normalize-meta");
const normalize_access_1 = require("../normalize-access");
const arrays_1 = require("../../../../../../../util/arrays");
const normalize_expressions_1 = require("../structure/normalize-expressions");
const normalize_call_1 = require("../functions/normalize-call");
const normalize_definition_1 = require("../functions/normalize-definition");
const type_1 = require("../../../../model/type");
const normalize_comment_1 = require("../other/normalize-comment");
/**
 * Returns an expression list if there are multiple children, otherwise returns the single child directly with no expr wrapper
 *
 * @param data - The data used by the parser (see {@link NormalizerData})
 * @param entry  - The JSON object to extract the meta-information from
 */
function normalizeExpression(data, entry) {
    const { content, location } = (0, normalize_meta_1.retrieveMetaStructure)(entry);
    const childrenSource = entry.children;
    const typed = (0, normalize_meta_1.getWithTokenType)(childrenSource);
    const { others, comments } = (0, normalize_expressions_1.splitComments)(typed);
    const childData = { ...data, currentRange: location, currentLexeme: content };
    const maybeFunctionCall = (0, normalize_call_1.tryNormalizeFunctionCall)(childData, others);
    if (maybeFunctionCall !== undefined) {
        maybeFunctionCall.info.additionalTokens = [...maybeFunctionCall.info.additionalTokens ?? [], ...comments.map(x => (0, normalize_comment_1.normalizeComment)(data, x.content))];
        return maybeFunctionCall;
    }
    const maybeAccess = (0, normalize_access_1.tryNormalizeAccess)(childData, others);
    if (maybeAccess !== undefined) {
        maybeAccess.info.additionalTokens = [...maybeAccess.info.additionalTokens ?? [], ...comments.map(x => (0, normalize_comment_1.normalizeComment)(data, x.content))];
        return maybeAccess;
    }
    const maybeFunctionDefinition = (0, normalize_definition_1.tryNormalizeFunctionDefinition)(childData, others);
    if (maybeFunctionDefinition !== undefined) {
        maybeFunctionDefinition.info.additionalTokens = [...maybeFunctionDefinition.info.additionalTokens ?? [], ...comments.map(x => (0, normalize_comment_1.normalizeComment)(data, x.content))];
        return maybeFunctionDefinition;
    }
    const children = (0, normalize_expressions_1.normalizeExpressions)(childData, childrenSource);
    const [delimiters, nodes] = (0, arrays_1.partition)(children, x => x.type === type_1.RType.Delimiter || x.type === type_1.RType.Comment);
    if (nodes.length === 1) {
        const result = nodes[0];
        result.info.additionalTokens = [...result.info.additionalTokens ?? [], ...delimiters];
        return result;
    }
    else {
        return {
            type: type_1.RType.ExpressionList,
            grouping: undefined,
            location,
            children: nodes,
            lexeme: content,
            info: {
                fullRange: childData.currentRange,
                additionalTokens: delimiters,
                fullLexeme: childData.currentLexeme
            }
        };
    }
}
//# sourceMappingURL=normalize-expression.js.map