"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryNormalizeParameter = tryNormalizeParameter;
const parser_1 = require("../../../json/parser");
const normalize_meta_1 = require("../../normalize-meta");
const assert_1 = require("../../../../../../../util/assert");
const type_1 = require("../../../../model/type");
const normalize_single_node_1 = require("../structure/normalize-single-node");
/**
 * Either parses `[SYMBOL_FORMALS]` or `[SYMBOL_FORMALS, EQ_FORMALS, expr]` as a parameter of a function definition in R.
 * Probably directly called by the function definition parser as otherwise, we do not expect to find parameters.
 *
 * @param data - The data used by the parser (see {@link NormalizerData})
 * @param objs - Either `[SYMBOL_FORMALS]` or `[SYMBOL_FORMALS, EQ_FORMALS, expr]`
 *
 * @returns The parsed parameter or `undefined` if the given object is not a parameter.
 */
function tryNormalizeParameter(data, objs) {
    if (objs.length !== 1 && objs.length !== 3) {
        parser_1.parseLog.warn(`Either [SYMBOL_FORMALS] or [SYMBOL_FORMALS, EQ_FORMALS, expr], but got: ${JSON.stringify(objs)}`);
        return undefined;
    }
    const symbol = objs[0];
    if (symbol.name !== type_1.RawRType.SymbolFormals) {
        parser_1.parseLog.warn(`expected symbol for parameter, yet received ${JSON.stringify(objs)}`);
        return undefined;
    }
    const defaultValue = objs.length === 3 ? parseWithDefaultValue(data, objs) : undefined;
    const { location, content } = (0, normalize_meta_1.retrieveMetaStructure)(symbol.content);
    const delim = defaultValue?.type === type_1.RType.Delimiter;
    return {
        type: type_1.RType.Parameter,
        location,
        special: content === '...',
        lexeme: content,
        name: {
            type: type_1.RType.Symbol,
            location, content,
            namespace: undefined,
            lexeme: content,
            info: {
                fullRange: location,
                additionalTokens: [],
                fullLexeme: content
            }
        },
        defaultValue: delim ? undefined : defaultValue,
        info: {
            fullRange: location,
            fullLexeme: content,
            additionalTokens: delim ? [defaultValue] : []
        }
    };
}
function parseWithDefaultValue(data, objs) {
    (0, assert_1.guard)(objs[1].name === type_1.RawRType.EqualFormals, () => `[arg-default] second element of parameter must be ${type_1.RawRType.EqualFormals}, but: ${JSON.stringify(objs)}`);
    const snd = objs[2];
    (0, assert_1.guard)(snd.name === type_1.RawRType.Expression, () => `[arg-default] third element of parameter must be an Expression but: ${JSON.stringify(objs)}`);
    return (0, normalize_single_node_1.normalizeSingleNode)(data, snd);
}
//# sourceMappingURL=normalize-parameter.js.map