"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.foldAstStateful = foldAstStateful;
const assert_1 = require("../../../../../util/assert");
const type_1 = require("../type");
const r_function_call_1 = require("../nodes/r-function-call");
/**
 * Folds in old functional-fashion over the AST structure but allowing for a down function which can pass context to child nodes.
 */
function foldAstStateful(ast, down, folds) {
    const type = ast.type;
    down = folds.down(ast, down);
    switch (type) {
        case type_1.RType.Number:
            return folds.foldNumber(ast, down);
        case type_1.RType.String:
            return folds.foldString(ast, down);
        case type_1.RType.Logical:
            return folds.foldLogical(ast, down);
        case type_1.RType.Symbol:
            return folds.foldSymbol(ast, down);
        case type_1.RType.Comment:
            return folds.other.foldComment(ast, down);
        case type_1.RType.LineDirective:
            return folds.other.foldLineDirective(ast, down);
        case type_1.RType.Pipe:
            return folds.foldPipe(ast, foldAstStateful(ast.lhs, down, folds), foldAstStateful(ast.rhs, down, folds), down);
        case type_1.RType.BinaryOp:
            return folds.foldBinaryOp(ast, foldAstStateful(ast.lhs, down, folds), foldAstStateful(ast.rhs, down, folds), down);
        case type_1.RType.UnaryOp:
            return folds.foldUnaryOp(ast, foldAstStateful(ast.operand, down, folds), down);
        case type_1.RType.Access:
            return folds.foldAccess(ast, foldAstStateful(ast.accessed, down, folds), ast.access.map(access => access === r_function_call_1.EmptyArgument ? r_function_call_1.EmptyArgument : foldAstStateful(access, down, folds)), down);
        case type_1.RType.ForLoop:
            return folds.loop.foldFor(ast, foldAstStateful(ast.variable, down, folds), foldAstStateful(ast.vector, down, folds), foldAstStateful(ast.body, down, folds), down);
        case type_1.RType.WhileLoop:
            return folds.loop.foldWhile(ast, foldAstStateful(ast.condition, down, folds), foldAstStateful(ast.body, down, folds), down);
        case type_1.RType.RepeatLoop:
            return folds.loop.foldRepeat(ast, foldAstStateful(ast.body, down, folds), down);
        case type_1.RType.FunctionCall:
            return folds.functions.foldFunctionCall(ast, foldAstStateful(ast.named ? ast.functionName : ast.calledFunction, down, folds), ast.arguments.map(param => param === r_function_call_1.EmptyArgument ? param : foldAstStateful(param, down, folds)), down);
        case type_1.RType.FunctionDefinition:
            return folds.functions.foldFunctionDefinition(ast, ast.parameters.map(param => foldAstStateful(param, down, folds)), foldAstStateful(ast.body, down, folds), down);
        case type_1.RType.Parameter:
            return folds.functions.foldParameter(ast, foldAstStateful(ast.name, down, folds), ast.defaultValue ? foldAstStateful(ast.defaultValue, down, folds) : undefined, down);
        case type_1.RType.Argument:
            return folds.functions.foldArgument(ast, ast.name ? foldAstStateful(ast.name, down, folds) : undefined, ast.value ? foldAstStateful(ast.value, down, folds) : undefined, down);
        case type_1.RType.Next:
            return folds.loop.foldNext(ast, down);
        case type_1.RType.Break:
            return folds.loop.foldBreak(ast, down);
        case type_1.RType.IfThenElse:
            return folds.foldIfThenElse(ast, foldAstStateful(ast.condition, down, folds), foldAstStateful(ast.then, down, folds), ast.otherwise === undefined ? undefined : foldAstStateful(ast.otherwise, down, folds), down);
        case type_1.RType.ExpressionList:
            return folds.foldExprList(ast, ast.grouping ? [foldAstStateful(ast.grouping[0], down, folds), foldAstStateful(ast.grouping[1], down, folds)] : undefined, ast.children.map(expr => foldAstStateful(expr, down, folds)), down);
        default:
            (0, assert_1.assertUnreachable)(type);
    }
}
//# sourceMappingURL=stateful-fold.js.map