"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryToNormalizeArgument = tryToNormalizeArgument;
const parser_1 = require("../../../json/parser");
const normalize_meta_1 = require("../../normalize-meta");
const assert_1 = require("../../../../../../../util/assert");
const type_1 = require("../../../../model/type");
const normalize_single_node_1 = require("../structure/normalize-single-node");
const strings_1 = require("../../../../../../../util/strings");
/**
 * Either parses `[expr]` or `[SYMBOL_SUB, EQ_SUB, expr]` as an argument of a function call in R.
 * Probably directly called by the function call parser as otherwise, we do not expect to find arguments.
 *
 * @param data - The data used by the parser (see {@link NormalizerData})
 * @param objs - Either `[expr]` or `[SYMBOL_FORMALS, EQ_FORMALS, expr]`
 *
 * @returns The parsed argument or `undefined` if the given object is not an argument.
 */
function tryToNormalizeArgument(data, objs) {
    if (objs.length < 1 || objs.length > 3) {
        parser_1.parseLog.warn(`Either [expr|value], [SYMBOL_SUB, EQ_SUB], or [SYMBOL_SUB, EQ_SUB, expr], but got: ${objs.map(o => o.name).join(', ')}`);
        return undefined;
    }
    const symbolOrExpr = objs[0];
    const { location, content } = (0, normalize_meta_1.retrieveMetaStructure)(symbolOrExpr.content);
    let parsedValue;
    let name;
    if (symbolOrExpr.name === type_1.RawRType.Expression) {
        name = undefined;
        parsedValue = (0, normalize_single_node_1.normalizeSingleNode)(data, symbolOrExpr);
    }
    else if (symbolOrExpr.name === type_1.RawRType.SymbolSub || symbolOrExpr.name === type_1.RawRType.StringConst) {
        name = {
            type: type_1.RType.Symbol,
            location,
            content: symbolOrExpr.name === type_1.RawRType.StringConst ? content.slice(1, -1) : ((0, strings_1.startAndEndsWith)(content, '`') ? content.slice(1, -1) : content),
            namespace: undefined,
            lexeme: content,
            info: {
                fullRange: location,
                additionalTokens: [],
                fullLexeme: content
            }
        };
        parsedValue = parseWithValue(data, objs);
    }
    else {
        parser_1.parseLog.warn(`expected symbol or expr for argument, yet received ${objs.map(o => o.name).join(',')}`);
        return undefined;
    }
    (0, assert_1.guard)(parsedValue !== undefined && parsedValue?.type !== type_1.RType.Delimiter, () => `[argument] parsed value must not be undefined, yet: ${JSON.stringify(objs)}`);
    return {
        type: type_1.RType.Argument,
        location,
        lexeme: content,
        name,
        value: parsedValue ?? undefined,
        info: {
            fullRange: location,
            fullLexeme: content,
            additionalTokens: []
        }
    };
}
function parseWithValue(data, objs) {
    (0, assert_1.guard)(objs[1].name === type_1.RawRType.EqualSub, () => `[arg-default] second element of parameter must be ${type_1.RawRType.EqualFormals}, but: ${JSON.stringify(objs)}`);
    const snd = objs[2];
    (0, assert_1.guard)(objs.length === 2 || snd.name === type_1.RawRType.Expression, () => `[arg-default] third element of parameter must be an Expression or undefined (for 'x=') but: ${JSON.stringify(objs)}`);
    return snd ? (0, normalize_single_node_1.normalizeSingleNode)(data, snd) : null;
}
//# sourceMappingURL=normalize-argument.js.map