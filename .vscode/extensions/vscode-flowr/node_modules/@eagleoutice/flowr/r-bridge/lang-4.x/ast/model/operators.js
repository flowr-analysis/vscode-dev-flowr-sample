"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnaryOperatorsInRAst = exports.OperatorsInRAst = exports.Operators = exports.OperatorDatabase = void 0;
const type_1 = require("./type");
/* eslint-disable */
exports.OperatorDatabase = {
    /* model formulae */
    '~': { name: 'model formulae', stringUsedInRAst: type_1.RawRType.Tilde, stringUsedInternally: '~', writtenAs: 'infix', arity: 3 /* OperatorArity.Both */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'model-formula', 'function-calls'] },
    /* arithmetic */
    '+': { name: 'addition or unary +', stringUsedInRAst: type_1.RawRType.Plus, stringUsedInternally: '+', writtenAs: 'infix', arity: 3 /* OperatorArity.Both */, usedAs: 'operation', capabilities: ['function-calls'] },
    '-': { name: 'subtraction or unary -', stringUsedInRAst: type_1.RawRType.Minus, stringUsedInternally: '-', writtenAs: 'infix', arity: 3 /* OperatorArity.Both */, usedAs: 'operation', capabilities: ['function-calls'] },
    '*': { name: 'multiplication', stringUsedInRAst: type_1.RawRType.Times, stringUsedInternally: '*', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    '/': { name: 'division', stringUsedInRAst: type_1.RawRType.Div, stringUsedInternally: '/', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    '^': { name: 'exponentiation', stringUsedInRAst: type_1.RawRType.Exp, stringUsedInternally: '^', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    /* no error, R uses ^ to represent ** in the AST */
    '**': { name: 'alternative exponentiation', stringUsedInRAst: type_1.RawRType.Exp, stringUsedInternally: '**', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    '%%': { name: 'modulus', stringUsedInRAst: '%%', stringUsedInternally: '%%', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'special-operator', 'function-calls'] },
    '%/%': { name: 'integer division', stringUsedInRAst: '%/%', stringUsedInternally: '%/%', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'special-operator', 'function-calls'] },
    '%*%': { name: 'matrix product', stringUsedInRAst: '%*%', stringUsedInternally: '%*%', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'special-operator', 'function-calls'] },
    '%o%': { name: 'outer product', stringUsedInRAst: '%o%', stringUsedInternally: '%o%', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'special-operator', 'function-calls'] },
    '%x%': { name: 'kronecker product', stringUsedInRAst: '%x%', stringUsedInternally: '%x%', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'special-operator', 'function-calls'] },
    /* comparison */
    '==': { name: 'equal to', stringUsedInRAst: type_1.RawRType.Eq, stringUsedInternally: '==', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    '!=': { name: 'not equal to', stringUsedInRAst: type_1.RawRType.Ne, stringUsedInternally: '!=', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    '>': { name: 'greater than', stringUsedInRAst: type_1.RawRType.Gt, stringUsedInternally: '>', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    '>=': { name: 'greater than or equal to', stringUsedInRAst: type_1.RawRType.Ge, stringUsedInternally: '>=', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    '<': { name: 'less than', stringUsedInRAst: type_1.RawRType.Lt, stringUsedInternally: '<', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    '<=': { name: 'less than or equal to', stringUsedInRAst: type_1.RawRType.Le, stringUsedInternally: '<=', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    /* logical */
    '&': { name: 'logical and (vectorized)', stringUsedInRAst: type_1.RawRType.And, stringUsedInternally: '&', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls', 'non-strict-logical-operators'] },
    '&&': { name: 'logical and (non-vectorized)', stringUsedInRAst: type_1.RawRType.And2, stringUsedInternally: '&&', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls', 'non-strict-logical-operators'] },
    '|': { name: 'logical or (vectorized)', stringUsedInRAst: type_1.RawRType.Or, stringUsedInternally: '|', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls', 'non-strict-logical-operators'] },
    '||': { name: 'logical or (not-vectorized)', stringUsedInRAst: type_1.RawRType.Or2, stringUsedInternally: '||', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls', 'non-strict-logical-operators'] },
    '!': { name: 'unary not', stringUsedInRAst: type_1.RawRType.Exclamation, stringUsedInternally: '!', writtenAs: 'prefix', arity: 1 /* OperatorArity.Unary */, usedAs: 'operation', capabilities: ['unary-operator', 'function-calls'] },
    '%in%': { name: 'matching operator', stringUsedInRAst: '%in%', stringUsedInternally: '%in%', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'special-operator', 'function-calls'] },
    /* assignment */
    '<-': { name: 'left assignment', stringUsedInRAst: type_1.RawRType.LeftAssign, stringUsedInternally: '<-', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'assignment', capabilities: ['binary-operator', 'infix-calls', 'assignment-functions', 'local-left-assignment', 'function-calls'] },
    ':=': { name: 'left assignment', stringUsedInRAst: type_1.RawRType.LeftAssign, stringUsedInternally: ':=', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'assignment', capabilities: ['binary-operator', 'infix-calls', 'assignment-functions', 'local-table-assignment', 'function-calls'] },
    '<<-': { name: 'left global assignment', stringUsedInRAst: type_1.RawRType.LeftAssign, stringUsedInternally: '<<-', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'assignment', capabilities: ['binary-operator', 'infix-calls', 'assignment-functions', 'super-left-assignment', 'function-calls'] },
    '->': { name: 'right assignment', stringUsedInRAst: type_1.RawRType.RightAssign, stringUsedInternally: '->', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'assignment', capabilities: ['binary-operator', 'infix-calls', 'assignment-functions', 'local-right-assignment', 'function-calls'] },
    '->>': { name: 'right global assignment', stringUsedInRAst: type_1.RawRType.RightAssign, stringUsedInternally: '->>', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'assignment', capabilities: ['binary-operator', 'infix-calls', 'assignment-functions', 'super-right-assignment', 'function-calls'] },
    '=': { name: 'equal assignment', stringUsedInRAst: type_1.RawRType.EqualAssign, stringUsedInternally: '=', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'assignment', capabilities: ['binary-operator', 'infix-calls', 'assignment-functions', 'local-equal-assignment', 'function-calls'] },
    /* others */
    /* maybe introduce custom in-r-ast flavor for these? we consider it arithmetic, as it works on numbers => if we change this we have to create custom tests! (with arithmetic, there is the automatic test set) */
    ':': { name: 'sequence operator', stringUsedInRAst: type_1.RawRType.Colon, stringUsedInternally: ':', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    '?': { name: 'question', stringUsedInRAst: type_1.RawRType.Question, stringUsedInternally: '?', writtenAs: 'prefix', arity: 1 /* OperatorArity.Unary */, usedAs: 'operation', capabilities: ['unary-operator', 'built-in-help'] }
};
/* eslint-enable */
function buildOperatorRAstCollection(operators) {
    return new Set(operators.map(op => exports.OperatorDatabase[op].stringUsedInRAst));
}
exports.Operators = Object.keys(exports.OperatorDatabase);
// '**' will be treated as '^'
exports.OperatorsInRAst = buildOperatorRAstCollection(exports.Operators);
exports.UnaryOperatorsInRAst = buildOperatorRAstCollection(exports.Operators.filter(op => exports.OperatorDatabase[op].arity !== 2 /* OperatorArity.Binary */));
//# sourceMappingURL=operators.js.map