"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RShellExecutor = void 0;
const shell_1 = require("./shell");
const objects_1 = require("../util/objects");
const child_process_1 = require("child_process");
const preload_1 = __importDefault(require("semver/preload"));
const log_1 = require("../util/log");
const init_1 = require("./init");
const convert_values_1 = require("./lang-4.x/convert-values");
const retriever_1 = require("./retriever");
const executorLog = log_1.log.getSubLogger({ name: 'RShellExecutor' });
/**
 * This is a synchronous alternative to the {@link RShell}.
 * Please be aware that using this is expensive.
 * Every request effectively causes a new initialization of the R interpreter.
 *
 * With this class you can {@link RShellExecutor#run|run(command)} commands,
 * that are potentially decorated with {@link RShellExecutor#addPrerequisites|prerequisites}.
 * For compatibility,
 * we provide {@link RShellExecutor#parse|parse(request)} and {@link RShellExecutor#rVersion|rVersion()}.
 */
class RShellExecutor {
    name = 'r-shell';
    options;
    prerequisites;
    constructor(options) {
        this.options = (0, objects_1.deepMergeObject)((0, shell_1.getDefaultRShellOptions)(), options);
        this.prerequisites = [(0, init_1.initCommand)(this.options.eol)];
    }
    /**
     * Adds commands that should be executed for every {@link RShellExecutor#run|run}.
     */
    addPrerequisites(commands) {
        this.prerequisites.push(...(typeof commands == 'string' ? [commands] : commands));
        return this;
    }
    /**
     * @returns the version of the R interpreter available to this executor.
     *
     * @see {@link RShellExecutor#usedRVersion}
     * @see {@link RShell#rVersion}
     * @see {@link RShell#usedRVersion}
     */
    rVersion() {
        return Promise.resolve(this.usedRVersion()?.format() ?? 'unknown');
    }
    /**
     * Instead of returning a promise, this method returns the version of the R interpreter available to this executor,
     * in the SemVer format.
     */
    usedRVersion() {
        const version = this.run(`cat(paste0(R.version$major,".",R.version$minor), ${(0, convert_values_1.ts2r)(this.options.eol)})`);
        (0, log_1.expensiveTrace)(executorLog, () => `raw version: ${JSON.stringify(version)}`);
        return preload_1.default.coerce(version);
    }
    /**
     * Runs the given command in the R interpreter.
     */
    run(command, returnErr = false) {
        command += ';base::quit()';
        (0, log_1.expensiveTrace)(executorLog, () => `> ${JSON.stringify(command)}`);
        const returns = (0, child_process_1.spawnSync)(this.options.pathToRExecutable, this.options.commandLineOptions, {
            env: this.options.env,
            cwd: this.options.cwd,
            windowsHide: true,
            encoding: 'utf8',
            input: [...this.prerequisites, command].join(this.options.eol)
        });
        return (returnErr ? returns.stderr : returns.stdout).trim();
    }
    /**
     * Parses the given request and returns the result.
     */
    parse(request) {
        return (0, retriever_1.retrieveParseDataFromRCode)(request, this);
    }
    close() { }
}
exports.RShellExecutor = RShellExecutor;
//# sourceMappingURL=shell-executor.js.map